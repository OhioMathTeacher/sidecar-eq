"""Sidecar EQ - Educational audio player with thermometer-style EQ interface.

This is the main application module containing the MainWindow class and
the primary UI logic. The application provides:

- Multi-source playback (local files, YouTube URLs, Plex media servers)
- 7-band thermometer EQ interface with per-track persistence
- Background audio analysis (frequency response, tempo, etc.)
- Queue management with drag-and-drop support
- Recently played tracks history
- Save/load playlist functionality

The UI is built using PySide6 (Qt6) and consists of:
- Top toolbar with playback controls and source selector
- Central queue table showing tracks
- Right side panel with volume knob, EQ faders, and recently played
- Bottom status bar with seek slider and time display
"""

# Standard library imports
import json
import math
import os
import sys
from pathlib import Path
from typing import Optional

# Third-party imports
from dotenv import load_dotenv
from plexapi.server import PlexServer
from PySide6.QtCore import QDateTime, QModelIndex, QObject, QSize, Qt, QThread, QTimer, Signal
from PySide6.QtGui import QAction, QIcon, QKeyEvent, QKeySequence, QPainter, QPixmap
from PySide6.QtMultimedia import QMediaPlayer
from PySide6.QtMultimediaWidgets import QVideoWidget
from PySide6.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QDial,
    QFileDialog,
    QHeaderView,
    QInputDialog,
    QLabel,
    QListWidgetItem,
    QMainWindow,
    QMessageBox,
    QProgressBar,
    QPushButton,
    QSlider,
    QSplitter,
    QStyle,
    QTableView,
    QToolBar,
    QWidget,
)

# Local imports
from . import playlist, store
from .indexer import LibraryIndexer
from .player import Player
from .queue_model import QueueModel
from .plex_helpers import get_playlist_titles, get_tracks_for_playlist
from .search import SearchBar
from .ui import IconButton, KnobWidget, QueueTableView, SnapKnobWidget, WaveformProgress
from .workers import BackgroundAnalysisWorker

# Media file extensions
AUDIO_EXTS = {".wav", ".flac", ".mp3", ".ogg", ".m4a"}
VIDEO_EXTS = {".mp4", ".mov", ".avi", ".mkv", ".flv", ".m4v", ".webm", ".wmv", ".3gp"}
MEDIA_EXTS = AUDIO_EXTS | VIDEO_EXTS


class MainWindow(QMainWindow):
    """Main application window for Sidecar EQ.

    This class orchestrates the entire UI, building the toolbar with playback
    controls, the central queue table, the side panel with EQ controls, and
    the status bar. It manages:

    - Audio playback via Player wrapper (QMediaPlayer)
    - Queue model (add, remove, reorder tracks)
    - Background analysis workers for audio processing
    - Per-track EQ settings persistence
    - Recently played tracks history
    - Plex server integration (optional)

    The window layout consists of:
    - Top: Toolbar (play, stop, add, source selector, etc.)
    - Center: Queue table view
    - Right: Dock with volume knob, 7-band EQ faders, recently played list
    - Bottom: Status bar with seek slider and time display

    Attributes:
        model: QueueModel managing the playlist/queue
        table: QueueTableView displaying the queue
        player: Player instance wrapping QMediaPlayer
        current_row: Currently playing row index (or None)

    Args:
        parent: Parent widget (optional).
    """

    def __init__(self, parent=None):
        """Initialize the main window and build the UI.

        Creates the queue model, player, and table view, then calls builder
        methods to construct the toolbar, side panel, and status bar. Finally
        wires all signals and applies dock sizing.

        Args:
            parent: Parent widget, defaults to None.
        """
        super().__init__(parent)
        try:
            # On macOS, ensure toolbar doesn't merge into title bar invisibly
            self.setUnifiedTitleAndToolBarOnMac(False)
        except Exception:
            pass
        # Basic state
        self.current_row = None
        self._current_position = "00:00"
        self._current_duration = "00:00"
        
        # Play state tracking for radio button indicators
        from .play_state_delegate import PlayStateDelegate
        self._play_state = PlayStateDelegate.PLAY_STATE_STOPPED
        
        # Background analysis management
        self._analysis_worker = None
        self._pending_analysis_path = None

        # Library indexer
        try:
            self.indexer = LibraryIndexer()
        except Exception as e:
            print(f"[SidecarEQ] Indexer failed: {e}")
            self.indexer = None

        # Search bar
        try:
            self.search_bar = SearchBar()
            self.search_bar.result_selected.connect(self._on_search_result_selected)
            self.search_bar.command_entered.connect(self._on_command_entered)
            # Connect to indexer
            if self.indexer:
                self.search_bar.set_index(self.indexer.get_index())
        except Exception as e:
            print(f"[SidecarEQ] Search bar failed: {e}")
            self.search_bar = None

        # Model / table
        try:
            self.model = QueueModel()
            self.table = QueueTableView()
            self.table.setModel(self.model)
            self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
            self.table.setSelectionMode(QAbstractItemView.SingleSelection)  # Allow single row selection for drag-drop
            self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.EditKeyPressed)  # Enable editing
            self.table.clicked.connect(self._on_table_play)
            self.table.delete_key_pressed.connect(self.on_remove_selected)
            
            # Install custom delegate for play state indicator (column 0)
            from .play_state_delegate import PlayStateDelegate
            self.play_state_delegate = PlayStateDelegate(self.table)
            self.table.setItemDelegateForColumn(0, self.play_state_delegate)
            
            # Configure columns for professional appearance with expanded metadata
            from PySide6.QtWidgets import QHeaderView
            header = self.table.horizontalHeader()
            header.setStretchLastSection(True)  # Stretch last column to fill space
            
            # Column resize modes (14 columns total now)
            header.setSectionResizeMode(0, QHeaderView.Fixed)  # ‚óè (play state) - fixed width
            for col in range(1, 14):  # All other columns user-resizable
                header.setSectionResizeMode(col, QHeaderView.Interactive)
            
            # Set initial column widths (optimized for new metadata fields)
            self.table.setColumnWidth(0, 30)   # ‚óè Play state indicator
            self.table.setColumnWidth(1, 250)  # Title
            self.table.setColumnWidth(2, 150)  # Artist
            self.table.setColumnWidth(3, 150)  # Album
            self.table.setColumnWidth(4, 50)   # Year
            self.table.setColumnWidth(5, 120)  # Label
            self.table.setColumnWidth(6, 120)  # Producer
            self.table.setColumnWidth(7, 80)   # Rating (‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ)
            self.table.setColumnWidth(8, 70)   # Bitrate
            self.table.setColumnWidth(9, 60)   # Format
            self.table.setColumnWidth(10, 80)  # Sample Rate
            self.table.setColumnWidth(11, 70)  # Bit Depth
            self.table.setColumnWidth(12, 60)  # Duration
            self.table.setColumnWidth(13, 80)  # Play Count
            
            # Enable word wrap in headers for better text fit
            header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            
            # Hide vertical header (row numbers) for cleaner look
            self.table.verticalHeader().setVisible(False)
            
            # Alternating row colors for better readability
            self.table.setAlternatingRowColors(True)
            
            # Enable sorting by clicking column headers
            self.table.setSortingEnabled(True)
            
            # Enable drag & drop for reordering rows
            self.table.setDragEnabled(True)
            self.table.setAcceptDrops(True)
            self.table.setDropIndicatorShown(True)
            self.table.setDragDropMode(QAbstractItemView.InternalMove)
            self.table.setDefaultDropAction(Qt.MoveAction)
            self.table.setDragDropOverwriteMode(False)  # Insert instead of overwrite
            # CRITICAL: Show line indicator between rows, not rectangle on row
            # The drop indicator shows as a LINE between items, not a rectangle highlighting the row
            # This is controlled by setDropIndicatorShown(True) and setDragDropOverwriteMode(False)
            
            # Create container with restructured layout:
            # - Queue table (top, full width)
            # - Waveform (50%) | EQ sliders (50%) (middle, split panel)
            # - Search bar (bottom, full width)
            from PySide6.QtWidgets import QVBoxLayout, QHBoxLayout, QSplitter
            central_widget = QWidget()
            central_layout = QVBoxLayout()
            central_layout.setContentsMargins(0, 0, 0, 0)
            central_layout.setSpacing(0)
            
            # Queue table at top
            central_layout.addWidget(self.table)
            
            # Waveform/EQ split panel (middle) - to be populated later after _build_side_panel
            # We'll create this in _build_side_panel since we need the EQ sliders
            self._waveform_eq_splitter = None  # Placeholder, will be created in _build_side_panel
            
            # Search bar at bottom
            if self.search_bar:
                central_layout.addWidget(self.search_bar)
            
            central_widget.setLayout(central_layout)
            self.setCentralWidget(central_widget)
            
            # Load saved queue state
            self._load_queue_state()
            
            # Auto-refresh metadata for existing queue items (background operation)
            if self.model and hasattr(self.model, '_rows') and len(self.model._rows) > 0:
                QTimer.singleShot(500, self._auto_refresh_metadata)
        except Exception as e:
            print(f"[SidecarEQ] Model/table setup failed: {e}")
            import traceback
            traceback.print_exc()
            self.model = None
            self.table = None

        # Player wrapper
        try:
            self.player = Player()
        except Exception:
            self.player = None

        # Build UI sections (safe-call)
        try:
            self._build_menubar()
        except Exception as e:
            print(f"[SidecarEQ] Menubar failed: {e}")
        try:
            self._build_toolbar()
        except Exception as e:
            print(f"[SidecarEQ] Toolbar failed: {e}")
            import traceback
            traceback.print_exc()
        try:
            self._build_side_panel()
        except Exception as e:
            print(f"[SidecarEQ] Side panel failed: {e}")
        try:
            self._build_status_bar()
        except Exception:
            pass

        # Wire signals last (player and widgets should exist)
        try:
            self._wire_signals()
        except Exception:
            pass

        self.setWindowTitle('Sidecar EQ')
        self.resize(1000, 640)
        
        # Apply clean dark theme with subtle accents
        self.setStyleSheet("""
            QMainWindow {
                background: #1e1e1e;
            }
            QTableView {
                background: #252525;
                color: #e0e0e0;
                gridline-color: #3a3a3a;
                border: 1px solid #3a3a3a;
                selection-background-color: #0d4f8f;
                selection-color: white;
            }
            QTableView QHeaderView::section {
                background: #2d2d2d;
                color: #c0c0c0;
                font-weight: bold;
                border: 1px solid #3a3a3a;
                padding: 5px;
            }
            QToolBar {
                background: #2a2a2a;
                border-bottom: 1px solid #404040;
                spacing: 6px;
                padding: 4px;
            }
            QStatusBar {
                background: #2a2a2a;
                color: #c0c0c0;
                border-top: 1px solid #404040;
            }
            QDockWidget {
                background: #1e1e1e;
                border-left: 1px solid #3a3a3a;
            }
            QLabel {
                color: #c0c0c0;
            }
        """)

    def _on_table_play(self, index):
        """
        Handle clicks on the queue table.
        - Column 0 (radio button): Play/pause/resume control
        - Other columns: Select row (no action)
        """
        try:
            # Only respond to clicks on column 0 (play state indicator)
            if index.column() != 0:
                return
            
            clicked_row = index.row()
            from .play_state_delegate import PlayStateDelegate
            
            # Case 1: Clicking the currently playing row - PAUSE it
            if clicked_row == self.current_row and self._play_state == PlayStateDelegate.PLAY_STATE_PLAYING:
                self.player.pause()
                self.statusBar().showMessage("Paused")
                self.play_btn.setActive(False)
                self.play_state_delegate.set_play_state(clicked_row, PlayStateDelegate.PLAY_STATE_PAUSED)
                self._play_state = PlayStateDelegate.PLAY_STATE_PAUSED
                
            # Case 2: Clicking a paused row - RESUME playback
            elif clicked_row == self.current_row and self._play_state == PlayStateDelegate.PLAY_STATE_PAUSED:
                self.player._player.play()
                self.statusBar().showMessage("Playing (resumed)")
                self.play_btn.setActive(True)
                self.play_state_delegate.set_play_state(clicked_row, PlayStateDelegate.PLAY_STATE_PLAYING)
                self._play_state = PlayStateDelegate.PLAY_STATE_PLAYING
                
            # Case 3: Clicking a different row - PLAY that track from beginning
            else:
                self._play_row(clicked_row)
                self._play_state = PlayStateDelegate.PLAY_STATE_PLAYING
                
        except Exception as e:
            print(f"[App] Error in _on_table_play: {e}")
            pass
    def _build_status_bar(self):
        sb = self.statusBar()
        sb.showMessage("Ready")
       
        # Waveform progress bar (click-to-seek, visual playback) - FIXED WIDTH
        self.waveform = WaveformProgress()
        self.waveform.setMinimumWidth(400)  # Fixed minimum width
        self.waveform.setMaximumHeight(70)  # Keep it compact
        sb.addPermanentWidget(self.waveform)

        # Time label with fixed width to prevent waveform jumping
        self.timeLabel = QLabel("00:00 / 00:00")
        self.timeLabel.setMinimumWidth(100)  # Fixed width prevents layout shifts
        self.timeLabel.setAlignment(Qt.AlignCenter)
        sb.addPermanentWidget(self.timeLabel)

        # Dragging should seek ‚Äî we wire it below in _wire_signals

        # time ‚Äúknob
        # self.progress = QProgressBar()
        # self.progress.setTextVisible(False)
        # sb.addPermanentWidget(self.progress)


    def _wire_signals(self):
        # play-end ‚Üí next track
        self.player.mediaStatusChanged.connect(
            lambda st: st == QMediaPlayer.EndOfMedia and self.on_next()
        )
        # wire duration/position to waveform and labels
        def _on_duration(dur):
            try:
                self.waveform.setDuration(int(dur))
            except Exception:
                pass
            self._on_duration(dur)

        def _on_position(pos):
            try:
                self.waveform.setPosition(int(pos))
            except Exception:
                pass
            self._on_position(pos)

        self.player.durationChanged.connect(_on_duration)
        self.player.positionChanged.connect(_on_position)

        # User seeking via waveform click ‚Üí set player position
        self.waveform.seekRequested.connect(lambda ms: self.player.set_position(ms))

    def _build_toolbar(self):
        print("[SidecarEQ] Building toolbar‚Ä¶")
        tb = QToolBar("Main")
        tb.setMovable(False)
        tb.setIconSize(QSize(32, 32))
        # Give the toolbar a subtle background so it's clearly visible
        tb.setStyleSheet("QToolBar{background:#202020; border-bottom:1px solid #333; padding:4px;}")
        self.addToolBar(tb)

        # Play/Pause button - HIDDEN (use radio buttons in queue instead)
        # Keep reference for internal play state tracking
        self.play_btn = IconButton(
            "icons/play.svg",
            "icons/play_hover.svg",
            "icons/play_active.svg",
            tooltip="Play / Pause (Space)"
        )
        self.play_btn.clicked.connect(self.on_play)
        self.play_btn.setShortcut(QKeySequence(Qt.Key_Space))
        self.play_btn.hide()  # Hidden - click radio buttons to play
        # tb.addWidget(self.play_btn)  # Commented out - not in toolbar

        # Stop button - HIDDEN (use radio buttons in queue instead)
        # stop_btn = IconButton(
        #     "icons/stop.svg",
        #     "icons/stop_hover.svg",
        #     "icons/stop_pressed.svg",
        #     tooltip="Stop (resets position)"
        # )
        # stop_btn.clicked.connect(self.on_stop)
        # tb.addWidget(stop_btn)

        # Add Songs button (download icon)
        # tb.addSeparator()  # No separator needed if play/stop hidden
        add_btn = IconButton(
            "icons/download.svg",
            "icons/download_hover.svg",
            "icons/download_pressed.svg",
            tooltip="Add Songs"
        )
        add_btn.clicked.connect(self.on_add_based_on_source)
        tb.addWidget(add_btn)

        # Trash button
        tb.addSeparator()
        trash_btn = IconButton(
            "icons/trash.svg",
            "icons/trash_hover.svg",
            "icons/trash_pressed.svg",
            tooltip="Remove Selected"
        )
        trash_btn.clicked.connect(self.on_remove_selected)
        tb.addWidget(trash_btn)

        # NOW PLAYING / METADATA DISPLAY - Extended to fill available space
        # LCD-style display inspired by retro alarm clocks and digital displays
        tb.addSeparator()
        self.metadata_label = QLabel("‚ô™ No track loaded")
        self.metadata_label.setStyleSheet("""
            QLabel {
                color: #00ff00;
                font-family: 'Courier New', 'Courier', 'Lucida Console', monospace;
                font-size: 14px;
                font-weight: bold;
                padding: 8px 16px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #0a0f0a, stop:0.5 #0d140d, stop:1 #0a0f0a);
                border: 2px solid #1a3a1a;
                border-radius: 6px;
            }
        """)
        # Make it expand to fill available space (but allow text truncation with ...)
        from PySide6.QtWidgets import QSizePolicy as _SP
        self.metadata_label.setSizePolicy(_SP.Expanding, _SP.Preferred)
        self.metadata_label.setMinimumWidth(200)
        # Enable text elision (show ... for long text)
        from PySide6.QtCore import Qt as _Qt
        self.metadata_label.setTextFormat(_Qt.PlainText)
        tb.addWidget(self.metadata_label)
        
        # NOTE: Removed Save EQ button - EQ auto-saves on change now
    print("[SidecarEQ] Toolbar ready")

    def _build_side_panel(self):
        """
        Build the waveform/EQ split panel.
        This creates a horizontal split: Waveform (left 50%) | EQ sliders (right 50%)
        The panel is inserted into the central layout between the queue table and search bar.
        """
        from PySide6.QtWidgets import (
            QWidget, QVBoxLayout, QLabel, QHBoxLayout, QSplitter
        )

        # Create horizontal splitter for waveform | EQ
        splitter = QSplitter(Qt.Horizontal)
        splitter.setChildrenCollapsible(False)  # Prevent collapsing panels
        
        # === LEFT PANEL: Waveform (taller for better visualization) ===
        waveform_panel = QWidget()
        waveform_layout = QVBoxLayout()
        waveform_layout.setContentsMargins(8, 8, 8, 8)
        waveform_layout.setSpacing(4)
        
        # Create waveform widget (moved from status bar)
        from .ui import WaveformProgress
        self.waveform = WaveformProgress()
        self.waveform.setMinimumHeight(150)  # Taller than before (was 70px)
        self.waveform.setMaximumHeight(200)
        waveform_layout.addWidget(self.waveform)
        
        # Time label below waveform
        self.timeLabel = QLabel("00:00 / 00:00")
        self.timeLabel.setAlignment(Qt.AlignCenter)
        self.timeLabel.setStyleSheet("color: #808080; font-size: 12px;")
        waveform_layout.addWidget(self.timeLabel)
        
        waveform_panel.setLayout(waveform_layout)
        waveform_panel.setStyleSheet("""
            QWidget {
                background: #1a1a1a;
                border: 1px solid #2a2a2a;
                border-radius: 4px;
            }
        """)
        
        # === RIGHT PANEL: EQ Sliders (compact layout) ===
        eq_panel = QWidget()
        eq_panel.setStyleSheet("""
            QWidget {
                background: #1a1a1a;
                border: 1px solid #2a2a2a;
                border-radius: 4px;
            }
        """)
        self._eq_bg_widget = eq_panel  # Store reference for opacity menu
        
        eq_main_layout = QVBoxLayout()
        eq_main_layout.setContentsMargins(8, 8, 8, 8)
        eq_main_layout.setSpacing(4)
        
        # EQ sliders container
        from PySide6.QtWidgets import QHBoxLayout as HB
        eq_x_offset = 12
        eq_layout = HB()
        eq_layout.setContentsMargins(eq_x_offset, 14, eq_x_offset, 14)
        eq_layout.setSpacing(16)  # Slightly more compact

        self._eq_sliders = []
        
        # RED VOLUME SLIDER style (first slider only)
        slider_css_red_volume = (
            # The groove (track) - dark recessed
            "QSlider::groove:vertical { "
            "background: #0a0a0a; "
            "width: 14px; border: 1px solid #1a1a1a; "
            "border-radius: 2px; margin: 0px; "
            "}"
            # The filled part (RED volume indicator)
            "QSlider::add-page:vertical { "
            "background: qlineargradient(x1:0, y1:0, x2:0, y2:1, "
            "stop:0 #ff6666, stop:0.4 #ff3333, stop:0.7 #cc0000, stop:1 #7a0000); "
            "border: none; "
            "border-radius: 2px; margin: 0px; "
            "}"
            # The handle (fader cap)
            "QSlider::handle:vertical { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #404040, stop:0.5 #505050, stop:1 #404040); "
            "width: 22px; height: 16px; margin: -4px 0; "
            "border: 1px solid #2a2a2a; "
            "border-radius: 2px; "
            "}"
            # Hover state - red accent
            "QSlider::handle:vertical:hover { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #4a4a4a, stop:0.5 #5a5a5a, stop:1 #4a4a4a); "
            "border: 1px solid #ff4d4d; "
            "}"
            # Pressed state - darker with red
            "QSlider::handle:vertical:pressed { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #2a2a2a, stop:0.5 #3a3a3a, stop:1 #2a2a2a); "
            "border: 1px solid #8f0d0d; "
            "}"
        )
        
        # 70s receiver-style VU meters with blue glow (for EQ sliders 2-7)
        slider_css_blue_vu = (
            # The groove (VU meter track) - dark recessed
            "QSlider::groove:vertical { "
            "background: #0a0a0a; "
            "width: 14px; border: 1px solid #1a1a1a; "
            "border-radius: 2px; margin: 0px; "
            "}"
            # The filled part (blue VU glow) - classic 70s receiver blue
            "QSlider::add-page:vertical { "
            "background: qlineargradient(x1:0, y1:0, x2:0, y2:1, "
            "stop:0 #66b3ff, stop:0.4 #3399ff, stop:0.7 #0066cc, stop:1 #003d7a); "
            "border: none; "
            "border-radius: 2px; margin: 0px; "
            "}"
            # The handle (fader cap) - subtle dark style
            "QSlider::handle:vertical { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #404040, stop:0.5 #505050, stop:1 #404040); "
            "width: 22px; height: 16px; margin: -4px 0; "
            "border: 1px solid #2a2a2a; "
            "border-radius: 2px; "
            "}"
            # Hover state - blue accent
            "QSlider::handle:vertical:hover { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #4a4a4a, stop:0.5 #5a5a5a, stop:1 #4a4a4a); "
            "border: 1px solid #4da6ff; "
            "}"
            # Pressed state - darker with blue
            "QSlider::handle:vertical:pressed { "
            "background: qlineargradient(x1:0, y1:0, x2:1, y2:0, "
            "stop:0 #2a2a2a, stop:0.5 #3a3a3a, stop:1 #2a2a2a); "
            "border: 1px solid #0d4f8f; "
            "}"
        )

        # Create 8 sliders: VOLUME (red) + 7 EQ bands (blue)
        for i in range(8):
            s = QSlider(Qt.Vertical)
            
            if i == 0:
                # VOLUME slider (red) - range 0-100
                s.setRange(0, 100)
                s.setValue(10)  # Default 10% volume
                s.setStyleSheet(slider_css_red_volume)
                s.valueChanged.connect(self._on_volume_changed)
                self._volume_slider = s  # Store reference
            else:
                # EQ sliders (blue) - range -12 to +12 dB
                s.setRange(-12, 12)
                s.setValue(0)
                s.setStyleSheet(slider_css_blue_vu)
                s.valueChanged.connect(self._on_eq_changed)
            
            s.setFixedHeight(150)  # Slightly shorter to fit in split panel
            eq_layout.addWidget(s)
            self._eq_sliders.append(s)

        eq_main_layout.addLayout(eq_layout)
        
        # Add labels: VOLUME + 7 EQ frequency labels
        freq_layout = HB()
        freq_layout.setContentsMargins(eq_x_offset, 0, eq_x_offset, 8)
        freq_layout.setSpacing(16)
        for freq in ["VOLUME", "60 Hz", "150 Hz", "400 Hz", "1 kHz", "2.4 kHz", "6 kHz", "15 kHz"]:
            label = QLabel(freq)
            label.setAlignment(Qt.AlignCenter)
            # Make VOLUME label red to match the slider
            if freq == "VOLUME":
                label.setStyleSheet("color: #ff4d4d; font-size: 9px; font-family: 'Helvetica'; font-weight: bold; background: transparent; border: none;")
            else:
                label.setStyleSheet("color: #808080; font-size: 9px; font-family: 'Helvetica'; font-weight: normal; background: transparent; border: none;")
            freq_layout.addWidget(label)
        eq_main_layout.addLayout(freq_layout)
        
        eq_panel.setLayout(eq_main_layout)
        
        # Add panels to splitter (50/50 split)
        splitter.addWidget(waveform_panel)
        splitter.addWidget(eq_panel)
        splitter.setSizes([500, 500])  # Equal widths initially
        
        # Insert splitter into central layout (between table and search bar)
        central_widget = self.centralWidget()
        if central_widget:
            central_layout = central_widget.layout()
            if central_layout:
                # Insert at index 1 (after table, before search bar)
                central_layout.insertWidget(1, splitter)
                self._waveform_eq_splitter = splitter

    def _on_volume_changed(self, val):
        """Handle volume slider changes (slider 0, red, range 0-100)."""
        try:
            if hasattr(self.player, 'set_volume'):
                self.player.set_volume(val / 100.0)
        except Exception:
            pass
        # Save volume setting for current track
        try:
            self._save_volume_for_current_track(val)
        except Exception as e:
            print(f"[App] Failed to save volume: {e}")

    def _build_menubar(self):
        """Create a macOS-native menubar with File/Playback/View/Help."""
        mb = self.menuBar()

        # File menu
        m_file = mb.addMenu("File")
        act_add_files = QAction("Add Files‚Ä¶", self); act_add_files.triggered.connect(self.on_add_files)
        act_add_folder = QAction("Add Folder‚Ä¶", self); act_add_folder.triggered.connect(self.on_add_folder)
        act_save_pl = QAction("Save Playlist‚Ä¶", self); act_save_pl.triggered.connect(self.on_save_playlist)
        act_load_pl = QAction("Load Playlist‚Ä¶", self); act_load_pl.triggered.connect(self.on_load_playlist)
        act_refresh_meta = QAction("Refresh Metadata", self); act_refresh_meta.triggered.connect(self.on_refresh_metadata)
        act_save_eq = QAction("Save Song EQ", self); act_save_eq.triggered.connect(self._safe_save_eq)
        act_index_folder = QAction("Index Music Folder for Search‚Ä¶", self); act_index_folder.triggered.connect(self.on_index_folder)
        act_quit = QAction("Quit", self); act_quit.setShortcut(QKeySequence.Quit); act_quit.triggered.connect(lambda: QApplication.instance().quit())
        for a in [act_add_files, act_add_folder, act_save_pl, act_load_pl, act_refresh_meta, act_save_eq, act_index_folder]:
            m_file.addAction(a)
        m_file.addSeparator(); m_file.addAction(act_quit)

        # Playback menu
        m_play = mb.addMenu("Playback")
        act_play = QAction("Play / Pause", self); act_play.setShortcut(Qt.Key_Space); act_play.triggered.connect(self.on_play)
        act_stop = QAction("Stop", self); act_stop.triggered.connect(self.on_stop)
        act_next = QAction("Next", self); act_next.setShortcut(QKeySequence.MoveToNextWord); act_next.triggered.connect(self.on_next)
        for a in [act_play, act_stop, act_next]: m_play.addAction(a)

        # View menu (EQ Opacity)
        m_view = mb.addMenu("View")
        from PySide6.QtGui import QActionGroup
        grp = QActionGroup(self); grp.setExclusive(True)
        self._eq_opacity_actions = {}
        def _add_opc(name, val):
            act = QAction(name, self); act.setCheckable(True)
            act.triggered.connect(lambda: self._set_eq_opacity(val))
            grp.addAction(act); m_view.addAction(act); self._eq_opacity_actions[name] = act
        _add_opc("EQ Plate Opacity ‚Ä¢ Low (30%)", 0.30)
        _add_opc("EQ Plate Opacity ‚Ä¢ Medium (60%)", 0.60)
        _add_opc("EQ Plate Opacity ‚Ä¢ High (90%)", 0.90)
        # Default to Medium
        self._eq_opacity_actions["EQ Plate Opacity ‚Ä¢ Medium (60%)"].setChecked(True)
        # Apply after side panel builds (safe-call)
        QTimer.singleShot(0, lambda: self._set_eq_opacity(0.60))

        # Search shortcut (Cmd+F / Ctrl+F)
        act_search = QAction("Search", self)
        act_search.setShortcut(QKeySequence.Find)
        act_search.triggered.connect(lambda: self.search_bar.focus_search() if self.search_bar else None)
        m_file.addAction(act_search)

        # Help menu
        m_help = mb.addMenu("Help")
        act_about = QAction("About Sidecar EQ", self)
        act_about.triggered.connect(lambda: QMessageBox.information(self, "About", "Sidecar EQ\nSimple local player with per-track EQ."))
        m_help.addAction(act_about)

    def _set_eq_opacity(self, level: float):
        """Set opacity on the EQ background plate (if present)."""
        try:
            bg = getattr(self, "_eq_bg_widget", None)
            if not bg: return
            from PySide6.QtWidgets import QGraphicsOpacityEffect
            eff = getattr(self, "_eq_opacity_effect", None)
            if eff is None:
                eff = QGraphicsOpacityEffect(self)
                self._eq_opacity_effect = eff
                bg.setGraphicsEffect(eff)
            eff.setOpacity(max(0.0, min(1.0, float(level))))
        except Exception:
            pass

    # --- Toolbar handlers ---
    def on_play(self):
        """Toggle between play and pause. Play button shows current state."""
        from .play_state_delegate import PlayStateDelegate
        
        # If currently playing, pause it
        if self.player.is_playing():
            self.player.pause()
            self.statusBar().showMessage("Paused")
            self.play_btn.setActive(False)  # Show as not active (paused state)
            # Update play state indicator to show paused (blinking)
            if self.current_row is not None:
                self.play_state_delegate.set_play_state(self.current_row, PlayStateDelegate.PLAY_STATE_PAUSED)
        else:
            # Check if we're in paused state (track loaded but not playing)
            if self.current_row is not None and self.player._player.playbackState() == QMediaPlayer.PausedState:
                # Resume from paused position
                self.player._player.play()
                self.statusBar().showMessage("Playing (resumed)")
                self.play_btn.setActive(True)
                # Update play state indicator back to playing
                self.play_state_delegate.set_play_state(self.current_row, PlayStateDelegate.PLAY_STATE_PLAYING)
            elif self.current_row is None:
                # No track loaded - start from selected or first row
                sel = self.table.selectionModel().selectedRows()
                self._play_row(sel[0].row() if sel else 0)
            else:
                # Track was stopped, restart from beginning
                self._play_row(self.current_row)

    def on_stop(self):
        """Stop playback and save current position for resume."""
        from .play_state_delegate import PlayStateDelegate
        
        if self.current_row is not None and self.player:
            # Save current position for potential resume
            try:
                current_pos = self.player._player.position()
                paths = self.model.paths()
                if self.current_row < len(paths):
                    path = paths[self.current_row]
                    # Store position in per-track settings
                    store_data = store.get_record(path) or {}
                    store_data['last_position_ms'] = current_pos
                    store.put_record(path, store_data)
                    print(f"[App] Saved position {current_pos}ms for resume")
            except Exception as e:
                print(f"[App] Failed to save position: {e}")
            
            # Update play state indicator to show stopped (before clearing current_row)
            self.play_state_delegate.set_play_state(self.current_row, PlayStateDelegate.PLAY_STATE_STOPPED)
            self._play_state = PlayStateDelegate.PLAY_STATE_STOPPED
        
        self.player.stop()
        self.statusBar().showMessage("Stopped")
        self.play_btn.setActive(False)

    def on_next(self):
        if self.current_row is None:
            self._play_row(0); return
        self._play_row(self.current_row + 1)

    def on_add_based_on_source(self):
        # v1.0.0: Local files only (Plex/Web deferred to v2.0.0)
        return self.on_add_files()

    def on_add_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, "Add Audio/Video Files", "", "Media Files (*.wav *.flac *.mp3 *.ogg *.m4a *.mp4 *.mov *.avi *.mkv *.flv *.m4v *.webm)"
        )
        if files:
            count = self.model.add_paths(files)
            if self.current_row is None and count > 0:
                self.table.selectRow(0)
            self.statusBar().showMessage(f"Added {count} files")

    def on_add_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "Add Folder")
        if not folder: return
        paths = []
        for root, _, files in os.walk(folder):
            for name in files:
                if name.startswith("._"):
                    continue
                if Path(name).suffix.lower() in MEDIA_EXTS:
                    paths.append(os.path.join(root, name))
        count = self.model.add_paths(paths)
        if self.current_row is None and count > 0:
            self.table.selectRow(0)
        self.statusBar().showMessage(f"Added {count} files from folder")

    def on_remove_selected(self):
        sel = self.table.selectionModel().selectedRows()
        rows = [ix.row() for ix in sel]
        self.model.remove_rows(rows)
        self.statusBar().showMessage(f"Removed {len(rows)} rows")

    def _on_search_result_selected(self, file_path: str, play_immediately: bool):
        """Handle selection of a search result.
        
        Args:
            file_path: Path to the selected audio file
            play_immediately: If True, add and play; if False, just add to queue
        """
        if not file_path or not Path(file_path).exists():
            self.statusBar().showMessage("File not found!", 3000)
            return
            
        # Add to queue
        count = self.model.add_paths([file_path])
        
        if count > 0:
            new_row = len(self.model._rows) - 1  # Last row added
            
            if play_immediately:
                # Play the new track immediately
                self._play_row(new_row)
                self.statusBar().showMessage(f"Playing: {Path(file_path).name}", 3000)
            else:
                # Just added to queue
                self.statusBar().showMessage(f"Added: {Path(file_path).name}", 2000)
                
    def _on_command_entered(self, command: str):
        """Handle command entered in search bar.
        
        Args:
            command: Command string (e.g., "HELP", "PLAYLIST local")
        """
        parts = command.strip().split()
        if not parts:
            return
            
        cmd = parts[0].upper()
        args = parts[1:] if len(parts) > 1 else []
        
        if cmd == "HELP":
            self._show_help_dialog()
        elif cmd == "PLAYLIST":
            self._handle_playlist_command(args)
        elif cmd == "EQ":
            self._handle_eq_command(args)
        else:
            self.statusBar().showMessage(f"Unknown command: {cmd}. Try HELP", 3000)
            
    def _show_help_dialog(self):
        """Show help dialog with available commands."""
        help_text = """<h2>Sidecar EQ Commands</h2>
        
        <p><b>Search:</b> Just type song names, artists, or albums!</p>
        
        <p><b>Available Commands:</b></p>
        <ul>
            <li><b>HELP</b> - Show this help dialog</li>
            <li><b>PLAYLIST local</b> - Load local .m3u playlist</li>
            <li><b>EQ export</b> - Export current EQ settings</li>
        </ul>
        
        <p><b>Tips:</b></p>
        <ul>
            <li>Press <b>Enter</b> to play the first result immediately</li>
            <li>Click a result to add it to the queue</li>
            <li>Tracks with ‚≠ê have saved EQ settings</li>
            <li>‚ñ∂ shows play count</li>
        </ul>
        """
        QMessageBox.information(self, "Sidecar EQ Help", help_text)
        
    def _handle_playlist_command(self, args: list):
        """Handle PLAYLIST command.
        
        Args:
            args: Command arguments
        """
        if not args or args[0] != "local":
            self.statusBar().showMessage("Usage: PLAYLIST local", 3000)
            return
            
        # Open file dialog for .m3u playlist
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Load Playlist", "", "Playlist Files (*.m3u *.m3u8)"
        )
        if file_path:
            self.on_load_playlist(file_path)
            
    def _handle_eq_command(self, args: list):
        """Handle EQ command.
        
        Args:
            args: Command arguments
        """
        if not args or args[0] != "export":
            self.statusBar().showMessage("Usage: EQ export", 3000)
            return
            
        # Export current EQ settings
        if self.current_row is not None and self.current_row < len(self.model._rows):
            track_info = self.model._rows[self.current_row]
            path = track_info.get("path", "")
            
            if path:
                settings = store.get_record(path)
                if settings and "eq" in settings:
                    # Show EQ values
                    eq_vals = settings["eq"]
                    msg = f"Current EQ:\n{eq_vals}"
                    QMessageBox.information(self, "EQ Settings", msg)
                else:
                    self.statusBar().showMessage("No EQ saved for this track", 3000)
            else:
                self.statusBar().showMessage("No track playing", 3000)
        else:
            self.statusBar().showMessage("No track playing", 3000)
            
    def on_index_folder(self):
        """Index a music folder for search functionality (runs in background)."""
        if not self.indexer:
            QMessageBox.warning(self, "Indexer Error", "Library indexer not available!")
            return
            
        folder = QFileDialog.getExistingDirectory(self, "Select Music Folder to Index")
        if not folder:
            return
            
        # Start background indexing thread
        self._start_background_indexing(folder)
        
    def _start_background_indexing(self, folder: str):
        """Start indexing in a background thread.
        
        Args:
            folder: Path to folder to index
        """
        from PySide6.QtCore import QRunnable, QThreadPool, QObject, Signal
        
        class ProgressSignals(QObject):
            """Signals for progress updates (must be QObject for thread safety)."""
            progress = Signal(int, int)  # scanned, added
            finished = Signal(int, int, str)  # added, total, error
        
        class IndexingTask(QRunnable):
            """Background task for indexing music library."""
            def __init__(self, indexer, folder, signals):
                super().__init__()
                self.indexer = indexer
                self.folder = folder
                self.signals = signals
                
            def run(self):
                """Run the indexing scan."""
                try:
                    def progress_callback(scanned, added):
                        self.signals.progress.emit(scanned, added)
                    
                    added = self.indexer.scan_folder(
                        self.folder, 
                        recursive=True,
                        progress_callback=progress_callback
                    )
                    total = len(self.indexer.get_index())
                    self.signals.finished.emit(added, total, "")
                except Exception as e:
                    import traceback
                    traceback.print_exc()
                    self.signals.finished.emit(0, 0, str(e))
        
        # Create signals
        signals = ProgressSignals()
        signals.progress.connect(self._on_indexing_progress)
        signals.finished.connect(self._on_indexing_complete)
        
        # Show initial status
        self.statusBar().showMessage(f"üîç Indexing {Path(folder).name}... You can keep using the app!", 0)
        
        # Create and start background task
        task = IndexingTask(self.indexer, folder, signals)
        QThreadPool.globalInstance().start(task)
        
    def _on_indexing_progress(self, scanned: int, added: int):
        """Handle progress updates from background indexer.
        
        Args:
            scanned: Number of audio files scanned so far
            added: Number of new tracks added so far
        """
        self.statusBar().showMessage(
            f"üîç Indexing... Scanned {scanned} files, added {added} new tracks", 
            0
        )
        
    def _on_indexing_complete(self, added: int, total: int, error: Optional[str]):
        """Handle indexing completion (called from background thread).
        
        Args:
            added: Number of tracks added
            total: Total tracks in index
            error: Error message if failed, None if successful
        """
        if error:
            self.statusBar().showMessage(f"Indexing failed: {error}", 5000)
            QMessageBox.warning(self, "Indexing Error", f"Failed to index folder:\n{error}")
            return
            
        # Update search bar with new index (on main thread)
        if self.search_bar:
            self.search_bar.set_index(self.indexer.get_index())
            
        # Show completion message
        self.statusBar().showMessage(
            f"‚úÖ Indexing complete! Added {added} new tracks. Total: {total} searchable tracks.", 
            5000
        )
        
        # Show dialog with results
        QMessageBox.information(
            self, 
            "Indexing Complete! üéµ", 
            f"Successfully indexed your music library!\n\n"
            f"‚Ä¢ Added: {added} new tracks\n"
            f"‚Ä¢ Total searchable: {total} tracks\n\n"
            f"You can now search for songs using the search bar at the top!\n"
            f"Try typing an artist or song name. üîç"
        )

    def _auto_refresh_metadata(self):
        """Silently refresh metadata on startup without status message."""
        self._refresh_metadata_internal(show_message=False)
    
    def on_refresh_metadata(self):
        """Re-scan all tracks in the queue and update their metadata."""
        self._refresh_metadata_internal(show_message=True)
    
    def _refresh_metadata_internal(self, show_message=True):
        """Internal method to refresh metadata."""
        if not self.model or not hasattr(self.model, '_rows'):
            return
        
        try:
            from mutagen import File as MutagenFile
        except:
            QMessageBox.warning(self, "Mutagen Not Installed", 
                              "Mutagen library is required for metadata reading.\nInstall with: pip install mutagen")
            return
        
        updated_count = 0
        for row in self.model._rows:
            path = row.get('path', '')
            if not path or path.startswith(('http://', 'https://')):
                continue  # Skip URLs
            
            try:
                # Re-read metadata using the improved logic
                mf = MutagenFile(path)
                if mf and hasattr(mf, 'tags') and mf.tags:
                    tags = mf.tags
                    
                    title = None
                    artist = None
                    album = None
                    
                    # Title
                    for key in ['TIT2', 'title', '¬©nam', 'TITLE']:
                        if key in tags:
                            val = tags[key]
                            title = str(val[0]) if isinstance(val, list) else str(val)
                            break
                    
                    # Artist
                    for key in ['TPE1', 'artist', '¬©ART', 'ARTIST']:
                        if key in tags:
                            val = tags[key]
                            artist = str(val[0]) if isinstance(val, list) else str(val)
                            break
                    
                    # Album
                    for key in ['TALB', 'album', '¬©alb', 'ALBUM']:
                        if key in tags:
                            val = tags[key]
                            album = str(val[0]) if isinstance(val, list) else str(val)
                            break
                    
                    # Update the row if we found any metadata
                    if any([title, artist, album]):
                        if title:
                            row['title'] = title
                        if artist:
                            row['artist'] = artist
                        if album:
                            row['album'] = album
                        updated_count += 1
            except Exception as e:
                print(f"[App] Failed to refresh metadata for {Path(path).name}: {e}")
                continue
        
        # Force table refresh
        self.model.layoutChanged.emit()
        if show_message:
            self.statusBar().showMessage(f"Refreshed metadata for {updated_count} tracks")
        print(f"[App] Refreshed metadata for {updated_count}/{len(self.model._rows)} tracks")

    def on_save_playlist(self):
        out, _ = QFileDialog.getSaveFileName(self, "Save Playlist (JSON)", "", "JSON (*.json)")
        if not out: return
        playlist.save_json(self.model.paths(), out)
        self.statusBar().showMessage(f"Saved playlist to {out}")

    def on_load_playlist(self):
        inp, _ = QFileDialog.getOpenFileName(self, "Load Playlist (JSON or M3U)", "", "Playlists (*.json *.m3u *.m3u8)")
        if not inp: return
        suffix = Path(inp).suffix.lower()
        if suffix == ".json":
            paths = playlist.load_json(inp)
        else:
            lines = Path(inp).read_text(errors="ignore").splitlines()
            paths = [ln for ln in lines if ln and not ln.startswith("#")]
        if paths:
            count = self.model.add_paths(paths)
            if self.current_row is None and count > 0:
                self.table.selectRow(0)
            self.statusBar().showMessage(f"Loaded {count} items")
        else:
            QMessageBox.information(self, "Load Playlist", "No paths found in playlist.")

    def _safe_save_eq(self):
        try:
            self.save_eq_for_current_track()
            self.statusBar().showMessage('EQ saved')
        except Exception as e:
            QMessageBox.warning(self, 'Save EQ', str(e))

    def import_plex_playlist(self):
        playlists = get_playlist_titles()  # list of (title, id)
        if not playlists:
            QMessageBox.information(self, "Plex", "No Plex playlists found.")
            return
        titles = [t for t, _ in playlists]
        title, ok = QInputDialog.getItem(self, "Import Plex Playlist", "Choose a playlist:", titles, 0, False)
        if not ok or not title:
            return
        # Find id for chosen title
        pl_id = None
        for t, pid in playlists:
            if t == title:
                pl_id = pid; break
        if not pl_id:
            QMessageBox.warning(self, "Plex", "Selected playlist not found.")
            return
        tracks = get_tracks_for_playlist(pl_id)
        if not tracks:
            QMessageBox.information(self, "Plex", "No tracks in the selected playlist.")
            return
        
        # Add tracks using the model's add_track method for Plex items
        count = 0
        for track in tracks:
            try:
                # The track already has the right format from plex_helpers.py
                added = self.model.add_track(track)
                count += added
            except Exception as e:
                print(f"[App] Failed to add Plex track: {e}")
                continue
        
        if not count:
            QMessageBox.information(self, "Plex", "No tracks could be imported from playlist.")
            return
            
        if self.current_row is None and count > 0:
            self.table.selectRow(0)
        self.statusBar().showMessage(f"Imported {count} tracks from Plex playlist: {title}")

    # --- Playback helpers ---
    def _play_row(self, row: int):
        paths = self.model.paths()
        if not paths or row is None or row < 0 or row >= len(paths):
            return
        
        # Cancel any running background analysis since we're switching tracks
        if self._analysis_worker and self._analysis_worker.isRunning():
            self._analysis_worker.stop_analysis()
            self._pending_analysis_path = None
        
        self.current_row = row
        
        # Get the track info to handle both local files, URLs, and Plex streams
        track_info = self.model._rows[row] if row < len(self.model._rows) else {}
        path = paths[row]
        
        # Update metadata display for the loaded track
        self._update_metadata_display(path)
        
        # Determine source type and playback URL
        # Robust source detection with validation
        stream_url = track_info.get('stream_url')
        
        if stream_url and stream_url.strip() and stream_url.startswith(('http://', 'https://')):
            # Plex track - has valid stream URL
            playback_url = stream_url
            identifier = stream_url
            source_type = 'plex'
        elif path and path.startswith(('http://', 'https://')):
            # Website URL - path is HTTP/HTTPS URL
            playback_url = path
            identifier = path
            source_type = 'url'  
        elif path and path.strip():
            # Local file - could be audio or video
            from .video_extractor import is_video_file, extract_audio_from_video
            
            if is_video_file(path):
                # Video file - extract audio for playback
                print(f"[App] Video file detected: {Path(path).name}")
                extracted_audio = extract_audio_from_video(path)
                if extracted_audio:
                    playback_url = str(extracted_audio)
                    identifier = path  # Use original video path as identifier
                    source_type = 'video'
                    print(f"[App] Using extracted audio: {Path(extracted_audio).name}")
                else:
                    print(f"[App] Failed to extract audio from: {Path(path).name}")
                    raise ValueError(f"Could not extract audio from video file: '{Path(path).name}'")
            else:
                # Regular audio file
                playback_url = path
                identifier = path
                source_type = 'local'
        else:
            # Invalid/empty path - this shouldn't happen
            print(f"[Error] Invalid path/URL for row {row}: path='{path}', track_info={track_info}")
            raise ValueError(f"Invalid path for playback: '{path}'")
        
        try:
            self.player.play(playback_url)
            self.play_btn.setActive(True)
            self.table.selectRow(row)
            
            # Update play state indicator to show playing
            from .play_state_delegate import PlayStateDelegate
            self.play_state_delegate.set_play_state(row, PlayStateDelegate.PLAY_STATE_PLAYING)
            self._play_state = PlayStateDelegate.PLAY_STATE_PLAYING
            
            title = self.model.data(self.model.index(row, 1))  # Title is now column 1 (was 0)
            
            # Show source type in status
            source_labels = {'local': '', 'url': 'from URL', 'plex': 'from Plex', 'video': 'from video'}
            source_label = source_labels.get(source_type, '')
            status_msg = f"Playing: {title}" + (f" ({source_label})" if source_label else "")
            self.statusBar().showMessage(status_msg)
            
            # Track play count using the identifier
            self._increment_play_count(identifier)
            
            # Handle EQ and analysis based on source type
            if source_type in ('plex', 'url'):
                # Streaming sources: just load saved settings (no analysis possible)
                eq_data = self.load_eq_for_track(identifier)
                if eq_data:
                    self._apply_eq_settings(eq_data.get('gains_db', [0]*7))
                    if 'suggested_volume' in eq_data:
                        self._apply_volume_setting(eq_data['suggested_volume'])
                    print(f"[App] Loaded saved EQ settings for streaming source: {Path(identifier).stem}")
                else:
                    # Reset to flat EQ for new streaming sources
                    self._apply_eq_settings([0]*7)
                    print(f"[App] No saved settings for streaming source: {Path(identifier).stem} - using flat EQ")
            elif source_type == 'video':
                # Video files: analyze extracted audio but use original video path as identifier
                print(f"[App] Analyzing extracted audio from video: {Path(identifier).name}")
                eq_data = self._get_or_analyze_eq(playback_url)  # Analyze the extracted audio file
                if eq_data:
                    # Save settings using video file path as key for consistency
                    self._apply_eq_settings(eq_data.get('gains_db', [0]*7))
                    # Store analysis under video file identifier
                    self._store_analysis_for_video(identifier, eq_data)
                else:
                    # Reset to flat EQ if no analysis available
                    self._apply_eq_settings([0]*7)
            else:
                # Regular local audio files: Check if we have saved EQ for this track, otherwise analyze
                eq_data = self._get_or_analyze_eq(identifier)
                if eq_data:
                    self._apply_eq_settings(eq_data.get('gains_db', [0]*7))
                else:
                    # Reset to flat EQ if no analysis available
                    self._apply_eq_settings([0]*7)
                
                # Always check for saved volume, independent of EQ data
                # This ensures manually-set volumes are preserved even before analysis
                print(f"[App] üîç Looking up settings for: {identifier}")
                saved_data = self.load_eq_for_track(identifier)
                if saved_data and 'suggested_volume' in saved_data:
                    self._apply_volume_setting(saved_data['suggested_volume'])
                else:
                    print(f"[App] ‚ö†Ô∏è  No saved volume found for this track")
                
        except Exception as e:
            QMessageBox.warning(self, "Play error", str(e))
    
    def _get_or_analyze_eq(self, path: str) -> dict:
        """Get saved EQ data or start background analysis if first time playing."""
        # First check if we have saved EQ settings
        try:
            saved_data = self.load_eq_for_track(path)
            if saved_data:
                # Also apply saved volume if available
                if 'suggested_volume' in saved_data:
                    self._apply_volume_setting(saved_data['suggested_volume'])
                return saved_data
        except Exception:
            pass
        
        # No saved EQ found, start background analysis
        self._start_background_analysis(path)
        return None
    
    def _start_background_analysis(self, path: str):
        """Start background analysis for the given track."""
        try:
            # Stop any existing analysis
            if self._analysis_worker and self._analysis_worker.isRunning():
                self._analysis_worker.stop_analysis()
                self._analysis_worker.wait(1000)  # Wait up to 1 second
            
            # Start new background analysis
            self._analysis_worker = BackgroundAnalysisWorker(path, self)
            self._analysis_worker.analysis_complete.connect(self._on_analysis_complete)
            self._analysis_worker.analysis_failed.connect(self._on_analysis_failed)
            self._pending_analysis_path = path
            
            self._analysis_worker.start()
            self.statusBar().showMessage(f"Playing: {Path(path).stem} (analyzing in background...)")
            
        except Exception as e:
            print(f"[App] Failed to start background analysis: {e}")
            self.statusBar().showMessage(f"Playing: {Path(path).stem}")
    
    def _on_analysis_complete(self, path: str, analysis_result: dict):
        """Handle completed background analysis."""
        try:
            # Check if this analysis is still relevant (user might have switched tracks)
            if path != self._pending_analysis_path:
                print(f"[App] Ignoring stale analysis for: {Path(path).stem}")
                return
            
            # Save the analysis results
            self._save_analysis_data(path, analysis_result)
            
            # Apply EQ and volume suggestions in real-time
            if analysis_result:
                # Apply EQ settings
                eq_data = analysis_result.get('eq_data', {})
                if eq_data:
                    self._apply_eq_settings(eq_data)
                
                # Apply volume suggestion
                analysis_data = analysis_result.get('analysis_data', {})
                if 'suggested_volume' in analysis_data:
                    self._apply_volume_setting(analysis_data['suggested_volume'])
                
                lufs = analysis_data.get('loudness_lufs', -23)
                self.statusBar().showMessage(f"Playing: {Path(path).stem} (analyzed: {lufs:.1f} LUFS - settings applied)")
                print(f"[App] Applied real-time analysis for: {Path(path).stem}")
            
        except Exception as e:
            print(f"[App] Error applying analysis results: {e}")
        finally:
            self._pending_analysis_path = None
    
    def _on_analysis_failed(self, path: str, error_message: str):
        """Handle failed background analysis."""
        print(f"[App] Background analysis failed for {Path(path).stem}: {error_message}")
        if path == self._pending_analysis_path:
            self.statusBar().showMessage(f"Playing: {Path(path).stem} (analysis failed)")
            self._pending_analysis_path = None
    
    def _apply_volume_setting(self, suggested_volume: int):
        """Apply suggested volume to the volume SLIDER (first slider, index 0) without triggering save."""
        try:
            if hasattr(self, '_volume_slider'):
                # Clamp to valid range (0-100)
                volume = max(0, min(100, suggested_volume))
                # Block signals to prevent saving this loaded value back to the track
                self._volume_slider.blockSignals(True)
                self._volume_slider.setValue(volume)
                self._volume_slider.blockSignals(False)
                print(f"[App] üìª LOADED volume {volume}%")
        except Exception as e:
            print(f"[App] Failed to apply volume: {e}")
    
    def _save_volume_for_current_track(self, volume_value: int):
        """Save volume setting for the currently playing track."""
        try:
            if self.current_row is None or not self.model:
                return
            
            # Get current track path
            track_path = self.model.data(self.model.index(self.current_row, 0), Qt.UserRole)
            if not track_path:
                return
            
            # Load existing EQ data or create new
            existing_data = self.load_eq_for_track(track_path) or {}
            
            # Update volume setting
            existing_data['suggested_volume'] = volume_value
            
            # Save back to file
            self._save_analysis_data(track_path, existing_data)
            print(f"[App] üíæ SAVED volume {volume_value}% for: {track_path}")
            
        except Exception as e:
            print(f"[App] Error saving volume: {e}")
    
    def _apply_eq_settings(self, gains_db: list):
        """Apply EQ settings to the sliders."""
        try:
            if hasattr(self, '_eq_sliders') and len(gains_db) >= len(self._eq_sliders):
                for i, slider in enumerate(self._eq_sliders):
                    if i < len(gains_db):
                        # Clamp to slider range (-12 to +12)
                        value = max(-12, min(12, int(gains_db[i])))
                        slider.setValue(value)
        except Exception as e:
            print(f"[App] Failed to apply EQ: {e}")
    
    def _on_eq_changed(self):
        """Handle EQ slider changes and apply audio effects.
        
        NOTE: Slider 0 is VOLUME (red), sliders 1-7 are EQ (blue).
        EQ visualization only! Qt's QMediaPlayer doesn't support real-time audio EQ.
        To add actual audio processing, you would need to integrate:
        - PyAudio + numpy for real-time DSP filtering, or
        - FFmpeg's audio filters (requires complex pipeline), or
        - A third-party audio engine like OpenAL or FMOD
        
        For now, the EQ sliders save settings per-track and provide visual feedback.
        """
        try:
            # Get EQ values from sliders 1-7 (skip slider 0 which is volume)
            eq_values = [slider.value() for slider in self._eq_sliders[1:]]
            
            # Apply EQ settings to the player (currently just stores values)
            self._apply_eq_to_player(eq_values)
            
            # Auto-save EQ settings for current track
            if self.current_row is not None:
                try:
                    self.save_eq_for_current_track()
                    print(f"[App] EQ changed and saved: {eq_values}")
                except Exception as save_error:
                    print(f"[App] EQ changed: {eq_values} (save failed: {save_error})")
            else:
                print(f"[App] EQ changed: {eq_values} (no current track to save)")
        except Exception as e:
            print(f"[App] Failed to handle EQ change: {e}")
    
    def _apply_eq_to_player(self, eq_values: list):
        """Apply EQ settings to audio playback."""
        try:
            if not hasattr(self, 'player') or not self.player:
                return
            
            # Send EQ values to player
            if hasattr(self.player, 'set_eq_values'):
                self.player.set_eq_values(eq_values)
                
            # Calculate overall volume adjustment based on EQ settings
            # This is a simplified approach - reduce volume if too many boosts
            total_boost = sum(max(0, val) for val in eq_values)
            
            # Apply a basic volume compensation to prevent clipping
            volume_compensation = 1.0
            if total_boost > 30:  # More than 30dB total boost
                volume_compensation = 0.6  # Significant reduction
            elif total_boost > 20:  # High boost
                volume_compensation = 0.75
            elif total_boost > 10:  # Moderate boost
                volume_compensation = 0.9
            
            # Get current volume setting and apply compensation
            if hasattr(self, '_volume_slider') and self._volume_slider and self._volume_slider.value() is not None:
                base_volume = self._volume_slider.value() / 100.0
                adjusted_volume = base_volume * volume_compensation
                
                # Apply to player
                if hasattr(self.player, 'set_volume'):
                    self.player.set_volume(adjusted_volume)
            else:
                # Default volume if no spinner available
                if hasattr(self.player, 'set_volume'):
                    self.player.set_volume(0.7 * volume_compensation)
                    
                # Calculate frequency-specific adjustments for user feedback
                bass_adjustment = eq_values[0] + eq_values[1]  # 60Hz + 150Hz
                mid_adjustment = eq_values[2] + eq_values[3]   # 400Hz + 1kHz
                treble_adjustment = eq_values[4] + eq_values[5] + eq_values[6]  # 2.4kHz + 6kHz + 15kHz
                
                print(f"[App] EQ Applied - Bass: {bass_adjustment:+.1f}dB, Mid: {mid_adjustment:+.1f}dB, Treble: {treble_adjustment:+.1f}dB")
                if hasattr(self, '_volume_slider') and self._volume_slider and self._volume_slider.value() is not None:
                    print(f"[App] Volume compensation: {volume_compensation:.2f} (base: {base_volume:.2f} -> adjusted: {adjusted_volume:.2f})")
                else:
                    print(f"[App] Volume compensation: {volume_compensation:.2f} (default volume used)")
        
        except Exception as e:
            print(f"[App] Failed to apply EQ to player: {e}")
    
    def _increment_play_count(self, path: str):
        """Increment play count for a track using the store module."""
        try:
            from . import store
            store.increment_play_count(path)
            
            # Update the model to refresh the play count display
            self._refresh_play_count_display(path)
            
            print(f"[App] Incremented play count for: {Path(path).stem}")
        except Exception as e:
            print(f"[App] Failed to increment play count: {e}")
    
    def _refresh_play_count_display(self, path: str):
        """Refresh the play count display for a specific track."""
        try:
            paths = self.model.paths()
            for row, model_path in enumerate(paths):
                if model_path == path:
                    # Update the play count in the model's internal data
                    from . import store
                    record = store.get_record(path) or {}
                    play_count = record.get('play_count', 0)
                    
                    if row < len(self.model._rows):
                        self.model._rows[row]['play_count'] = play_count
                        # Emit data changed signal to update the display
                        index = self.model.index(row, 3)  # Play Count column
                        self.model.dataChanged.emit(index, index)
                    break
        except Exception as e:
            print(f"[App] Failed to refresh play count display: {e}")
    
    def _save_analysis_data(self, path: str, analysis_data: dict):
        """Save analysis data to our EQ store with enhanced metadata."""
        try:
            p = self._eq_store_path()
            data = {}
            if p.exists():
                try:
                    data = json.loads(p.read_text())
                except Exception:
                    data = {}
            
            # Helper function to convert numpy types to native Python types for JSON serialization
            def convert_to_native(obj):
                """Recursively convert numpy types to native Python types."""
                import numpy as np
                if isinstance(obj, (np.integer, np.floating)):
                    return obj.item()
                elif isinstance(obj, np.ndarray):
                    return obj.tolist()
                elif isinstance(obj, dict):
                    return {k: convert_to_native(v) for k, v in obj.items()}
                elif isinstance(obj, (list, tuple)):
                    return [convert_to_native(item) for item in obj]
                return obj
            
            # Store both EQ settings and analysis metadata
            existing_track_data = data.get(path, {})
            data[path] = {
                'eq_settings': convert_to_native(analysis_data.get('gains_db', [0]*7)),
                'suggested_volume': convert_to_native(analysis_data.get('analysis_data', {}).get('suggested_volume')),
                'analysis_data': convert_to_native(analysis_data.get('analysis_data', {})),
                'analyzed_at': str(QDateTime.currentDateTime().toString()),
                'play_count': existing_track_data.get('play_count', 0),  # Don't increment here
                'manual_save': existing_track_data.get('manual_save', False)  # Preserve manual save flag
            }
            
            p.write_text(json.dumps(data, indent=2))
            
        except Exception as e:
            print(f"[App] Failed to save analysis data: {e}")

    def _on_position(self, pos_ms: int):
        mins, secs = divmod(pos_ms // 1000, 60)
        self._current_position = f"{mins:02d}:{secs:02d}"
        self.timeLabel.setText(f"{self._current_position} / {self._current_duration}")

    def _on_duration(self, dur_ms: int):
        mins, secs = divmod(dur_ms // 1000, 60)
        self._current_duration = f"{mins:02d}:{secs:02d}"
        self.timeLabel.setText(f"{self._current_position} / {self._current_duration}")

    # --- EQ persistence helpers ---
    def _eq_store_path(self):
        return Path.home() / '.sidecar_eq_eqs.json'

    def save_eq_for_current_track(self):
        """Save current EQ, volume, and any existing analysis data for the current track."""
        if self.current_row is None:
            raise RuntimeError('No current track to save EQ for')
        paths = self.model.paths()
        if not paths or self.current_row >= len(paths):
            raise RuntimeError('Invalid current row')
        
        path = paths[self.current_row]
        
        # Get current EQ slider values
        eq_values = [int(s.value()) for s in getattr(self, '_eq_sliders', [])]
        
        # Get current volume
        current_volume = self._volume_slider.value() if hasattr(self, '_volume_slider') else 75
        
        # Load existing data (to preserve analysis results)
        p = self._eq_store_path()
        data = {}
        if p.exists():
            try:
                data = json.loads(p.read_text())
            except Exception:
                data = {}
        
        # Get existing track data or create new
        existing_track_data = data.get(path, {})
        
        # Update with current manual settings
        track_data = {
            'eq_settings': eq_values,
            'suggested_volume': current_volume,
            'analysis_data': existing_track_data.get('analysis_data', {}),  # Preserve existing analysis
            'analyzed_at': existing_track_data.get('analyzed_at', str(QDateTime.currentDateTime().toString())),
            'play_count': existing_track_data.get('play_count', 0),
            'manual_save': True,  # Flag to indicate user manually saved settings
            'saved_at': str(QDateTime.currentDateTime().toString())
        }
        
        # Update the data and save
        data[path] = track_data
        p.write_text(json.dumps(data, indent=2))
        
        print(f"[App] Saved EQ and volume for: {Path(path).stem} (EQ: {eq_values}, Vol: {current_volume})")

    def _update_metadata_display(self, path: str):
        """Extract and display track + audio file metadata in the toolbar."""
        try:
            # Handle URLs differently - limited metadata
            if path.startswith(('http://', 'https://')):
                self.metadata_label.setText("üåê Streaming ‚Ä¢ No metadata available")
                return
            
            file_path = Path(path)
            if not file_path.exists():
                self.metadata_label.setText("‚ö†Ô∏è File not found")
                return
            
            # Get file size
            file_size_bytes = file_path.stat().st_size
            if file_size_bytes < 1024:
                size_str = f"{file_size_bytes}B"
            elif file_size_bytes < 1024 * 1024:
                size_str = f"{file_size_bytes / 1024:.1f}KB"
            else:
                size_str = f"{file_size_bytes / (1024 * 1024):.1f}MB"
            
            # Try to extract audio metadata with mutagen
            try:
                from mutagen import File as MutagenFile
                audio = MutagenFile(path)
                
                if audio is None:
                    # Fallback - just show filename
                    self.metadata_label.setText(f"‚ô™ {file_path.stem} ‚Ä¢ {file_path.suffix.upper()[1:]} ‚Ä¢ {size_str}")
                    return
                
                # Extract track info (title, artist, album)
                title = None
                artist = None
                album = None
                
                if hasattr(audio, 'tags') and audio.tags:
                    tags = audio.tags
                    # Try common tag names
                    for key in ['TIT2', 'title', '¬©nam', 'TITLE']:
                        if key in tags:
                            val = tags[key]
                            title = str(val[0]) if isinstance(val, list) else str(val)
                            break
                    for key in ['TPE1', 'artist', '¬©ART', 'ARTIST', 'TPE2', 'albumartist']:
                        if key in tags:
                            val = tags[key]
                            artist = str(val[0]) if isinstance(val, list) else str(val)
                            break
                    for key in ['TALB', 'album', '¬©alb', 'ALBUM']:
                        if key in tags:
                            val = tags[key]
                            album = str(val[0]) if isinstance(val, list) else str(val)
                            break
                
                # Fallback to filename for title
                if not title:
                    title = file_path.stem
                
                # Build the NOW PLAYING display: "Title - Artist ‚Ä¢ Album ‚Ä¢ FORMAT ‚Ä¢ details"
                parts = []
                
                # Song info first (most important)
                if artist:
                    parts.append(f"‚ô™ {title} - {artist}")
                else:
                    parts.append(f"‚ô™ {title}")
                
                if album:
                    parts.append(album)
                
                # Technical details
                format_name = file_path.suffix.upper()[1:]  # .flac -> FLAC
                sample_rate = getattr(audio.info, 'sample_rate', None)
                bits_per_sample = getattr(audio.info, 'bits_per_sample', None)
                bitrate = getattr(audio.info, 'bitrate', None)
                channels = getattr(audio.info, 'channels', None)
                
                # Format string
                tech_parts = [format_name]
                
                if bits_per_sample:
                    # Lossless format
                    tech_parts.append(f"{sample_rate / 1000:.1f}kHz/{bits_per_sample}bit")
                elif bitrate:
                    # Lossy format
                    tech_parts.append(f"{bitrate // 1000}kbps")
                
                if channels == 2:
                    tech_parts.append("Stereo")
                elif channels == 1:
                    tech_parts.append("Mono")
                
                tech_parts.append(size_str)
                
                parts.append(" ".join(tech_parts))
                
                # Final display text
                display_text = " ‚Ä¢ ".join(parts)
                self.metadata_label.setText(display_text)
                self.metadata_label.setToolTip(display_text)  # Full text on hover
                
            except Exception as e:
                # Fallback if mutagen fails
                self.metadata_label.setText(f"‚ô™ {file_path.stem} ‚Ä¢ {file_path.suffix.upper()[1:]} ‚Ä¢ {size_str}")
                print(f"[Metadata] Could not extract audio info: {e}")
                
        except Exception as e:
            self.metadata_label.setText("‚ö†Ô∏è Error reading metadata")
            print(f"[Metadata] Error: {e}")

    def load_eq_for_track(self, path):
        """Load EQ and volume data for a track. Returns dict with eq_settings and volume or None."""
        p = self._eq_store_path()
        if not p.exists():
            return None
        try:
            data = json.loads(p.read_text())
        except Exception:
            return None
        
        track_data = data.get(path)
        if not track_data:
            return None
        
        # Handle both old format (just values) and new format (dict with metadata)
        if isinstance(track_data, list):
            # Old format - just EQ values
            eq_settings = track_data
            suggested_volume = None
        elif isinstance(track_data, dict):
            # New format - with metadata
            eq_settings = track_data.get('eq_settings', track_data.get('gains_db', []))
            suggested_volume = track_data.get('suggested_volume')
        else:
            return None
        
        # Apply to sliders
        for s, v in zip(getattr(self, '_eq_sliders', []), eq_settings):
            s.setValue(int(v))
        
        # Apply volume if available
        if suggested_volume is not None:
            self._apply_volume_setting(suggested_volume)
        
        print(f"[App] Loaded settings for: {Path(path).stem} (EQ: {eq_settings[:3]}..., Vol: {suggested_volume})")
        
        # Return in analyzer format for consistency
        return {
            'gains_db': eq_settings,
            'suggested_volume': suggested_volume,
            'bands_hz': [31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000]
        }
    
    def _store_analysis_for_video(self, video_path: str, analysis_data: dict):
        """Store analysis data for a video file using the original video path as key."""
        try:
            p = self._eq_store_path()
            data = {}
            if p.exists():
                try:
                    data = json.loads(p.read_text())
                except Exception:
                    data = {}
            
            # Store under video file path with analysis from extracted audio
            track_data = {
                'eq_settings': analysis_data.get('gains_db', [0]*7),
                'suggested_volume': analysis_data.get('suggested_volume', 75),
                'analysis_data': analysis_data,
                'analyzed_at': str(QDateTime.currentDateTime().toString()),
                'play_count': data.get(video_path, {}).get('play_count', 0),
                'source_type': 'video'
            }
            
            data[video_path] = track_data
            p.write_text(json.dumps(data, indent=2))
            
            print(f"[App] Stored video analysis for: {Path(video_path).stem}")
            
        except Exception as e:
            print(f"[App] Failed to store video analysis: {e}")
    
    def closeEvent(self, event):
        """Clean up background analysis and save queue state when closing the application."""
        try:
            # Save queue state before closing
            self._save_queue_state()
            
            # Clean up background analysis
            if self._analysis_worker and self._analysis_worker.isRunning():
                print("[App] Stopping background analysis...")
                self._analysis_worker.stop_analysis()
                self._analysis_worker.wait(2000)  # Wait up to 2 seconds
        except Exception as e:
            print(f"[App] Error during cleanup: {e}")
        
        event.accept()

    def _get_queue_state_file(self):
        """Get the path to the queue state file."""
        home = Path.home()
        sidecar_dir = home / ".sidecar_eq"
        sidecar_dir.mkdir(exist_ok=True)
        return sidecar_dir / "queue_state.json"

    def _save_queue_state(self):
        """Save the current queue state to disk."""
        try:
            if self.model:
                queue_file = self._get_queue_state_file()
                self.model.save_queue_state(queue_file)
        except Exception as e:
            print(f"[App] Failed to save queue state: {e}")

    def _load_queue_state(self):
        """Load the saved queue state from disk."""
        try:
            if self.model:
                queue_file = self._get_queue_state_file()
                self.model.load_queue_state(queue_file)
        except Exception as e:
            print(f"[App] Failed to load queue state: {e}")

def main():
    """App entry point: configure environment, create QApplication, show MainWindow."""
    try:
        load_dotenv()
    except Exception:
        pass

    # High DPI support is automatic in Qt6, no need to set attributes
    # (AA_EnableHighDpiScaling and AA_UseHighDpiPixmaps are deprecated in Qt 6.10)

    app = QApplication.instance() or QApplication(sys.argv)

    # Fusion dark palette
    try:
        app.setStyle("Fusion")
        from PySide6.QtGui import QPalette, QColor
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(30, 30, 30))
        palette.setColor(QPalette.WindowText, Qt.white)
        palette.setColor(QPalette.Base, QColor(25, 25, 25))
        palette.setColor(QPalette.AlternateBase, QColor(45, 45, 45))
        palette.setColor(QPalette.ToolTipBase, Qt.white)
        palette.setColor(QPalette.ToolTipText, Qt.white)
        palette.setColor(QPalette.Text, Qt.white)
        palette.setColor(QPalette.Button, QColor(45, 45, 45))
        palette.setColor(QPalette.ButtonText, Qt.white)
        palette.setColor(QPalette.BrightText, Qt.red)
        palette.setColor(QPalette.Highlight, QColor(64, 128, 255))
        palette.setColor(QPalette.HighlightedText, Qt.black)
        app.setPalette(palette)
    except Exception:
        pass

    w = MainWindow()

    # Map hardware volume keys and +/- to control the app volume by 1 unit
    def _vol_key_filter(obj, event):
        try:
            from PySide6.QtCore import QEvent
            if event.type() == QEvent.KeyPress:
                if event.key() in (Qt.Key_VolumeUp, Qt.Key_Plus, Qt.Key_Equal):
                    # Find volume spinner and bump +1
                    try:
                        # We stored it on window during side panel build
                        if hasattr(w, '_volume_slider'):
                            w._volume_slider.setValue(w._volume_slider.value() + 1)
                            return True
                    except Exception:
                        pass
                if event.key() in (Qt.Key_VolumeDown, Qt.Key_Minus, Qt.Key_Underscore):
                    try:
                        if hasattr(w, '_volume_slider'):
                            w._volume_slider.setValue(w._volume_slider.value() - 1)
                            return True
                    except Exception:
                        pass
        except Exception:
            pass
        return False

    # Proper QObject-based event filter so installEventFilter receives a QObject
    class VolFilter(QObject):
        def __init__(self, handler, parent=None):
            super().__init__(parent)
            self._handler = handler
        def eventFilter(self, obj, event):
            try:
                return bool(self._handler(obj, event))
            except Exception:
                return False

    _vf = VolFilter(_vol_key_filter, app)
    app.installEventFilter(_vf)
    # Keep a Python-side ref so it isn't GC'd while the app runs
    setattr(app, "_vol_filter", _vf)
    w.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
